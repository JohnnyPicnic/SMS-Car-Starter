#define TINY_GSM_MODEM_SIM7600
#define TINY_GSM_RX_BUFFER          1024 // Set RX buffer to 1Kb
#define SerialAT                    Serial1

#include <TinyGsmClient.h>
#include <FS.h>
#include <SPIFFS.h>
#include <Arduino.h>
#include <driver/adc.h>
TinyGsm modem(SerialAT);

#define uS_TO_S_FACTOR      1000000ULL  /* Conversion factor for micro seconds to seconds */
#define TIME_TO_SLEEP       300          /* Time ESP32 will go to sleep (in seconds) */
#define UART_BAUD           115200

#define MODEM_TX            27
#define MODEM_RX            26
#define MODEM_PWRKEY        4
#define MODEM_DTR           32
#define MODEM_RI            33
#define MODEM_FLIGHT        25
#define MODEM_STATUS        34

#define LED_PIN             12
#define START_PIN           19   // Define the GPIO pin for START command
#define UNLOCK_PIN          21   // Define the GPIO pin for UNLOCK command
#define LOCK_PIN            22   // Define the GPIO pin for LOCK command
#define BATTERY_ADC_PIN     25   // Define the ADC GPIO pin for battery voltage measurement
#define VOLTAGE_DIVIDER_RATIO 5.0 // Adjust according to your voltage divider


void setup() {
    // Set console baud rate
    Serial.begin(115200); 

    // Initialize modem
    SerialAT.begin(UART_BAUD, SERIAL_8N1, MODEM_RX, MODEM_TX);
    delay(100);

    // Initialize control pins
    pinMode(START_PIN, OUTPUT);
    digitalWrite(START_PIN, HIGH); // Ensure the pin is initially off

    pinMode(UNLOCK_PIN, OUTPUT);
    digitalWrite(UNLOCK_PIN, HIGH); // Ensure the pin is initially off

    pinMode(LOCK_PIN, OUTPUT);
    digitalWrite(LOCK_PIN, HIGH); // Ensure the pin is initially off

    // Initialize the ADC pin
    pinMode(BATTERY_ADC_PIN, INPUT);

    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, HIGH);

    if (esp_sleep_get_wakeup_cause() != ESP_SLEEP_WAKEUP_TIMER) {
        pinMode(MODEM_PWRKEY, OUTPUT);
        digitalWrite(MODEM_PWRKEY, LOW);
        delay(100);
        digitalWrite(MODEM_PWRKEY, HIGH);
        delay(100);
        digitalWrite(MODEM_PWRKEY, LOW);

        pinMode(MODEM_FLIGHT, OUTPUT);
        digitalWrite(MODEM_FLIGHT, HIGH);
    } else {
        Serial.println("Wakeup modem !");
        gpio_hold_dis((gpio_num_t)MODEM_DTR);
        pinMode(MODEM_DTR, OUTPUT);
        digitalWrite(MODEM_DTR, LOW);
        delay(2000);
        modem.sleepEnable(false);
    }

    Serial.println("Check modem online .");
    while (!modem.testAT()) {
        Serial.print("."); delay(500);
    }
    // ---------------- APN CONFIG FOR KORE SUPER SIM ----------------
    Serial.println("Configuring APN = super");

    // Deactivate any existing context (ignore errors)
    modem.sendAT("+CNACT=0,1");
    modem.waitResponse(3000);

    // Configure PDP context #1 to APN "super"
    modem.sendAT("+CNCFG=0,1,\"super\"");
    modem.waitResponse(3000);

    // Bring up data context
    modem.sendAT("+CNACT=1,1");
    if (modem.waitResponse(8000, "OK")) {
        Serial.println("APN activated successfully!");
    } else {
        Serial.println("APN activation failed!");
    }

    // Optional: show IP address (helpful for debugging)
    modem.sendAT("+CNACT?");
    modem.waitResponse(3000);

    Serial.println("Modem is online !");
    Serial.println("Setup SMS storage");
    modem.sendAT("+CNMI=1,2,0,0,0");
    delay(5000);
    
}
void modem_sleep(){
  Serial.println("Enter modem sleep mode!");

    // Pull up DTR to put the modem into sleep
    pinMode(MODEM_DTR, OUTPUT);
    digitalWrite(MODEM_DTR, HIGH);
    // Set DTR to keep at high level, if not set, DTR will be invalid after ESP32 goes to sleep.
    gpio_hold_en((gpio_num_t )MODEM_DTR);
    gpio_deep_sleep_hold_en();

    if (modem.sleepEnable(true) != true) {
        Serial.println("Modem sleep failed!");
    } else {
        Serial.println("Modem sleeping!");
    }

}
void modem_wakeup (){
          Serial.println("Wakeup modem !");

        // Need to cancel GPIO hold if wake from sleep
        gpio_hold_dis((gpio_num_t )MODEM_DTR);

        // Pull down DTR to wake up MODEM
        pinMode(MODEM_DTR, OUTPUT);
        digitalWrite(MODEM_DTR, LOW);
        delay(2000);
        modem.sleepEnable(false);

        
}
esp_sleep_wakeup_cause_t wakeup_reason;
void print_wakeup_reason(){
 
  wakeup_reason = esp_sleep_get_wakeup_cause();
 
  // Print if if it was a GPIO or something else
  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}
// Function to check network registration
void checkAndReconnectNetwork() {
  // Check if the modem is already connected to the network
  if (!modem.isNetworkConnected()) {
    Serial.println("Network not connected. Attempting to reconnect...");
    
    // Wait for the modem to register on the network
    if (modem.waitForNetwork()) {
      Serial.println("Successfully connected to the network.");
    } else {
      Serial.println("Failed to connect to the network.");
      // Handle failure (e.g., retry, send error notification, etc.)
      // Optionally, you can add a retry mechanism here.
    }
  } else {
    Serial.println("Already connected to the network.");
  }
}
void checkSMS() {
    String smsContent = "";
    unsigned long timeout = millis() + 1000; // Set timeout for 1 second
    bool cmtDetected = false;

    // Clear serial buffer
    while (SerialAT.available()) {
        SerialAT.read();
    }

    // Read SMS
    while (millis() < timeout) {
        if (SerialAT.available()) {
            char c = (char)SerialAT.read();
            smsContent += c;

            if (smsContent.indexOf("+CMT:") != -1) {
                cmtDetected = true;
            }
            if (cmtDetected && smsContent.endsWith("\r\n\r\n")) {
                break;
            }
        }
        delay(10);
    }

    Serial.println("Received SMS:");
    Serial.println(smsContent);
 
    // Extract sender number
    int startIdx = smsContent.indexOf("+CMT: \"") + 7;
    int endIdx = smsContent.indexOf("\"", startIdx);
    String sender = smsContent.substring(startIdx, endIdx);
    Serial.println("Sender: " + sender);
    //Send Help

    handleFlashLEDCommand(smsContent);
    handleSMSCommand(smsContent, sender);
}
// Function to delete all SMS messages
void deleteAllSMS() {
  modem.sendAT("+CMGD=1,4");  // Command to delete all SMS (1 is the starting index, 4 means delete all)
  delay(1000);  // Wait for the modem to process the command

  String response = "";
  while (SerialAT.available()) {
    response += (char)SerialAT.read();  // Read the response from the modem
  }

  // Print the response from the modem
  Serial.println("Delete all SMS response: " + response);
}
// Function to handle Flash LED command and flash the LED
void handleFlashLEDCommand(String smsContent) {
    // Check if the SMS contains the "Flash LED" command
    int flashPos = smsContent.indexOf("Flash LED");

    if (flashPos != -1) {  // Only proceed if "Flash LED" is found
        int numberPos = flashPos + 9;  // Skip past "Flash LED" (9 characters)
        
        // Ensure that numberPos is within the bounds of the string
        if (numberPos < smsContent.length()) {
            // Extract the substring after "Flash LED" and trim any whitespace
            String numStr = smsContent.substring(numberPos);
            numStr.trim();  // Trim any leading or trailing whitespace
            
            // Debug print to check extracted number string
            Serial.println("Extracted number: " + numStr);
            
            // Convert the extracted string to an integer
            int flashCount = numStr.toInt();

            // If the number is valid (greater than 0), flash the LED
            if (flashCount > 0) {
                flashLED(flashCount);  // Call the flashLED function to flash the LED
            } else {
                Serial.println("Invalid flash count in message.");
            }
        } else {
            Serial.println("Error: Number position is out of bounds.");
        }
    } else {
        Serial.println("No 'Flash LED' command found in the SMS.");
    }
}
// Function to flash the LED the specified number of times
void flashLED(int count) {
    for (int i = 0; i < count; i++) {
        digitalWrite(LED_PIN, HIGH); // Turn LED on
        delay(150); // Wait for 500ms
        digitalWrite(LED_PIN, LOW); // Turn LED off
        delay(150); // Wait for 500ms before flashing again
    }
    Serial.print("Flashed the LED ");
    Serial.print(count);
    Serial.println(" times.");
}
// Function to handle incoming SMS commands
void handleSMSCommand(const String& smsContent, const String& sender) {
    // Convert the received SMS content to lowercase for case-insensitivity
    String command = toLowerCase(smsContent);

    if (command.indexOf("start?") != -1) {

    Serial.println("[START] Start? command received.");

    // ---- Read initial battery voltage ----
    float v1 = measureBatteryVoltage();
    Serial.println("[START] Initial Voltage: " + String(v1, 2) + "V");

    // ---- Pulse the starter relay ----
    digitalWrite(START_PIN, LOW);
    Serial.println("[START] START_PIN LOW");
    delay(500);
    digitalWrite(START_PIN, HIGH);
    Serial.println("[START] START_PIN HIGH");

    // ---- Wait 10 seconds ----
    modem_wakeup();
    Serial.println("[START] Waiting 10 seconds...");
    delay(10000);

    // ---- Read battery voltage again ----
    float v2 = measureBatteryVoltage();
    Serial.println("[START] Second Voltage: " + String(v2, 2) + "V");

    // ---- Determine if engine started ----
    float delta = v2 - v1;
    bool started = (delta >= 1.0);

    Serial.println("[START] Voltage Change: " + String(delta, 2) + "V");
    Serial.println(started ? "[START] Engine detected as RUNNING" 
                           : "[START] Engine NOT running");
    String message;
    if (started) {
        message = "Car Started. V1: " + String(v1, 2) + 
                  "V, V2: " + String(v2, 2) + 
                  "V (+" + String(delta, 2) + "V)";
    } else {
        message = "Car Not Started. V1: " + String(v1, 2) + 
                  "V, V2: " + String(v2, 2) + 
                  "V (+" + String(delta, 2) + "V)";
    }
    replyToIncomingCommand(sender, message);
    }
    else if (command.indexOf("start") != -1) {
        // Immediately start the car by toggling the relay
        digitalWrite(START_PIN, LOW);
        Serial.println("START_PIN set to LOW.");
        delay(500);
        digitalWrite(START_PIN, HIGH);
        Serial.println("START_PIN set to HIGH.");
    } 
    else if (command.indexOf("battery?") != -1) {
        // Measure the battery voltage
        float batteryVoltage = measureBatteryVoltage();
        Serial.println("Measured Battery Voltage: " + String(batteryVoltage, 2) + "V");

        // Send an SMS reply with the battery voltage
        String message = "Battery Voltage: " + String(batteryVoltage, 2) + "V";
        replyToIncomingCommand(sender, message); 
    } 
    else if (command.indexOf("unlock") != -1) {
        // Unlock the car
        digitalWrite(UNLOCK_PIN, LOW);
        Serial.println("UNLOCK_PIN set to LOW.");
        delay(500);
        digitalWrite(UNLOCK_PIN, HIGH);
        Serial.println("UNLOCK_PIN set to HIGH.");
    }
    else if (command.indexOf("lock") != -1) {
        // Lock the car
        digitalWrite(LOCK_PIN, LOW);
        Serial.println("LOCK_PIN set to LOW.");
        delay(500);
        digitalWrite(LOCK_PIN, HIGH);
        Serial.println("LOCK_PIN set to HIGH.");
    }
    // Check for temperature command
    else if (command.indexOf("check temp") != -1) {
        handleCheckTempCommand(sender);
    }
}
void sendSMS(const String& number, const String& message) {
    const int SMS_MAX = 160; // Max chars per SMS
    int start = 0;
    
    while (start < message.length()) {
        int end = start + SMS_MAX;
        if (end > message.length()) end = message.length();

        String chunk = message.substring(start, end);
        chunk.trim();

        // Wake modem if sleeping
        modem_wakeup();

        // Send chunk
        modem.sendAT("+CMGS=\"" + number + "\"");
        delay(100);
        modem.stream.write(chunk.c_str());
        delay(100);
        modem.stream.write((char)26); // CTRL+Z
        delay(1000); // Let modem process

        Serial.println("Sent SMS to " + number + ": " + chunk);

        start = end;
        delay(500); // Short pause between messages
    }

    modem_sleep();
}
bool sendKORE_IP_UDP(
    const String &payload,
    const char* serverIP = "100.64.0.1",
    uint16_t serverPort = 3030,
    uint16_t localPort = 5000,
    int maxRetries = 3
) {
    bool ok = true;  // Track failures but never exit early

    // Shadow payload
    String payloadLocal = payload.length() ? payload : "TEST";

    Serial.println("========== KORE UDP SEND ==========");
    modem_wakeup();

    // --- 0. Clear UART ---
    while (SerialAT.available()) SerialAT.read();
    delay(50);

    // --- 1. Check LTE registration ---
    Serial.println("[STEP] Checking LTE network (AT+CGREG?)...");
    bool attached = false;

    modem.sendAT("+CGREG?");
    String reg = SerialAT.readString();
    Serial.println("[CGREG RAW] " + reg);

    // --- 2. Attach PS service ---
    Serial.println("[STEP] CGATT=1");
    modem.sendAT("+CGATT=1");
    String reg1 = SerialAT.readString();
    Serial.println("[CGATT RAW] " + reg1);
 
    // --- 3. APN setup ---
    Serial.println("[STEP] Set APN to super");
    modem.sendAT("+CGDCONT=1,\"IP\",\"super\"");
    String reg2 = SerialAT.readString();
    Serial.println("[CGDCONT RAW] " + reg2);

    // --- 4. Activate PDP ---
    Serial.println("[STEP] Activate PDP (CGACT=1,1)");
    modem.sendAT("+CGACT=1,1");
    String reg3 = SerialAT.readString();
    Serial.println("[CGACT=1,1] " + reg3);

    // --- 5. NETOPEN ---
    Serial.println("[STEP] NETOPEN");
    modem.sendAT("+NETOPEN");
    String reg4 = SerialAT.readString();
    Serial.println("[CGACT=1,1] " + reg4);

    // --- 6. CIPOPEN (UDP socket) ---
    Serial.print("[STEP] Opening UDP socket: ");
    Serial.print(serverIP);
    Serial.print(":");
    Serial.println(serverPort);

    String cmd = String("+CIPOPEN=1,\"UDP\",\"") 
             + serverIP + "\"," 
             + String(serverPort) + "," 
             + String(localPort);

    modem.sendAT(cmd);
    String reg5 = SerialAT.readString();
    Serial.println("[CIPOPEN=1] " + reg5);

    // --- 7. CIPSEND ---
    Serial.println("[STEP] CIPSEND");

    String cmd1 = String("+CIPSEND=1,") 
                  + payloadLocal.length() 
                  + ",\"" 
                  + serverIP + "\"," 
                  + String(serverPort);

    modem.sendAT(cmd1);
    
    String reg6 = SerialAT.readString();
    Serial.println("[CIPSEND=1] " + reg6);
    SerialAT.print(payloadLocal);
    String reg7 = SerialAT.readString();
    Serial.println("[CIPSEND=Response ] " + reg7);
    // Wait for '>' prompt

   
    // --- 8. Close socket ---
    modem.sendAT("+CIPCLOSE=0");
    modem.waitResponse(3000);
    Serial.println("[CIPCLOSE] Done");

    // --- 9. NETCLOSE ---
    modem.sendAT("+NETCLOSE");
    modem.waitResponse(5000);
    Serial.println("[NETCLOSE] Done");

    // --- Final ---
    if (ok) Serial.println("[INFO] UDP payload sent successfully!");
    else    Serial.println("[WARN] Completed sequence but errors occurred.");

    return ok;
}
void replyToIncomingCommand(const String &sender, const String &msg) {
    Serial.println("[Reply] Attempting KORE IP Command reply...");
    if (sendKORE_IP_UDP(msg)) {
        Serial.println("[Reply] KORE IP Command delivered.");
        return;
    }

    Serial.println("[Reply] KORE send failed â†’ SMS fallback.");
    sendSMS(sender, msg);
}
void handleCheckTempCommand(const String& sender) {
    float temperature = readTemperature();
    String message = "Board Temperature: " + String(temperature);
    replyToIncomingCommand(sender, message);
    Serial.println("Sent temperature SMS to " + sender + ": " + message);
}
// Function to measure battery voltage
float measureBatteryVoltage() {
  // configure ADC attenuation for full-range reading of higher voltages
  // ADC attenuation options: ADC_0db, ADC_2_5db, ADC_6db, ADC_11db
  // Using 11db extends measurable voltage to ~3.6V on ADC pin
  analogSetPinAttenuation(BATTERY_ADC_PIN, ADC_11db);

  int raw = analogRead(BATTERY_ADC_PIN); // 0..4095
  if (raw < 0) raw = 0;
  if (raw > 4095) raw = 4095;

  // convert to voltage (assuming ADC reference ~3.3)
  float v_adc = (raw / 4095.0) * 3.3;
  float batteryV = (v_adc * VOLTAGE_DIVIDER_RATIO)-1.0;
  return batteryV;
}
float readTemperature() {
    float tempFahrenheit = temperatureRead();
    float tempCelsius = (tempFahrenheit - 32) * 5.0 / 9.0;
    return tempCelsius;
}
// Function to convert a string to lowercase
String toLowerCase(String str) {
    str.toLowerCase();
    return str;
}
void loop() {
 
    print_wakeup_reason();
    if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0){
      Serial.printf("Check SMS messages\r\n");
      checkSMS();
    }
    else if (wakeup_reason == ESP_SLEEP_WAKEUP_TIMER){
      Serial.printf("Check if modem is registered\r\n");
      modem_wakeup();
      checkAndReconnectNetwork();
      modem_sleep();
    };
    
    modem_sleep();
    digitalWrite(LED_PIN, LOW); // Turn LED off
    
    Serial.println("Enter esp32 sleep!");
    esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);
    esp_sleep_enable_gpio_wakeup();
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_33, 0);

    delay(200);
    esp_light_sleep_start();

}
